// Test1.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "IniProc.h"
#include <map>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// The one and only application object

CWinApp theApp;

using namespace std;

// Test.cpp : Defines the entry point for the console application.
//

#include <string>
#include <Shlwapi.h>
#include <algorithm>
#include <iterator>

//#include <iostream>
//#include<iterator>

#define BYTE unsigned char
std::vector<int[13]> cardsVec;
int i = 0;
int arr[14] = { 0 };
void ShowArr(BYTE baseCards[], BYTE cardsNum, BYTE charLineNum)
{
	int idex = 0;
	for (int i = 0; i < cardsNum; ++i)
	{
		printf("0x%02x, ", baseCards[i]);
		++idex;
		if (charLineNum == idex)
		{
			idex = 0;
			printf("\n\n");
		}
	}
}
void ChangeCards(BYTE& offset, BYTE* des, BYTE src[], BYTE num, BYTE baseNumTem)
{
	int baseNum = 0;
	int modefyNum = 0;
	std::vector<BYTE> baseVec(des, des + baseNumTem);
	std::vector<BYTE> modifyVec(src, src + num);
	//BYTE index[13] = {0xFF};
	auto modefyBegin = modifyVec.begin();
	auto modefyEnd = modifyVec.end();
	int idex = baseNumTem - 1;
	int modefyIdex = 0;
	auto basePtr = baseVec.rbegin();
	//获取对应索引，并将对应idex处置为0
	for (; modefyBegin != modefyEnd; ++modefyBegin)
	{
		BYTE data = *modefyBegin;
		int daaaa = *(baseVec.rbegin() + 13);
		auto findPtr = find(basePtr++, baseVec.rend(), *modefyBegin);
		if (baseVec.rend() != findPtr)
		{
			modefyIdex = baseVec.rend() - findPtr -1;
			BYTE dataTem = des[idex];
			des[idex] = *modefyBegin;
			des[modefyIdex] = dataTem;
			baseVec[modefyIdex] = dataTem;
			--idex;
		}
	}
	offset += 13;
}

typedef std::pair<WORD, WORD> PAIR;


int cmp(const pair<WORD, WORD>& x, const pair<WORD, WORD>& y)
{
	return x.second > y.second;
}

void sortMapByValue(map<WORD, WORD>& tMap, vector<pair<WORD, WORD> >& tVector)
{
	for (map<WORD, WORD>::iterator curr = tMap.begin(); curr != tMap.end(); curr++)
		tVector.push_back(make_pair(curr->first, curr->second));

	sort(tVector.begin(), tVector.end(), cmp);
}

bool MapSort(const std::pair<WORD, WORD>& lf, const std::pair<WORD, WORD>& ri)
{
	return lf.second > ri.second;
}

const static BYTE speciaCards[][13] =
{
	//4人：
	//万子好牌
	{ 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x15, 0x25, 0x06, 0x16, 0x27 },
	{ 0x08, 0x08, 0x09, 0x09, 0x07, 0x06, 0x05, 0x04, 0x15, 0x25, 0x06, 0x16, 0x27 },
	{ 0x01, 0x02, 0x03, 0x04, 0x06, 0x07, 0x02, 0x08, 0x09, 0x25, 0x06, 0x16, 0x27 },
	{ 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x07, 0x07, 0x09, 0x09, 0x06, 0x16, 0x27 },
	{ 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x03, 0x03, 0x01, 0x09, 0x06, 0x16, 0x27 },
	{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x09, 0x06, 0x16, 0x27 },

	//条子好牌
	{ 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x14, 0x25, 0x05, 0x16, 0x26, 0x07 },
	{ 0x18, 0x18, 0x19, 0x19, 0x17, 0x16, 0x15, 0x14, 0x25, 0x05, 0x16, 0x26, 0x07 },
	{ 0x11, 0x12, 0x13, 0x14, 0x16, 0x17, 0x12, 0x18, 0x19, 0x25, 0x16, 0x26, 0x07 },
	{ 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x17, 0x17, 0x19, 0x19, 0x16, 0x26, 0x07 },
	{ 0x15, 0x15, 0x15, 0x18, 0x18, 0x18, 0x13, 0x13, 0x11, 0x19, 0x16, 0x26, 0x07 },
	{ 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x16, 0x26, 0x07 },

	//筒子好牌
	{ 0x21, 0x21, 0x22, 0x22, 0x23, 0x23, 0x24, 0x24, 0x05, 0x15, 0x26, 0x06, 0x17 },
	{ 0x28, 0x28, 0x29, 0x29, 0x27, 0x26, 0x25, 0x24, 0x05, 0x15, 0x26, 0x06, 0x17 },
	{ 0x21, 0x22, 0x23, 0x24, 0x26, 0x27, 0x22, 0x28, 0x29, 0x05, 0x26, 0x06, 0x17 },
	{ 0x21, 0x21, 0x21, 0x22, 0x22, 0x22, 0x27, 0x27, 0x29, 0x29, 0x26, 0x06, 0x17 },
	{ 0x25, 0x25, 0x25, 0x28, 0x28, 0x28, 0x23, 0x23, 0x21, 0x29, 0x26, 0x06, 0x17 },
	{ 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 0x26, 0x06, 0x17 },

	//3人：
	//条子好牌
	{ 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x14, 0x25, 0x25, 0x16, 0x26, 0x27 },
	{ 0x18, 0x18, 0x19, 0x19, 0x17, 0x16, 0x15, 0x14, 0x25, 0x25, 0x16, 0x26, 0x27 },
	{ 0x11, 0x12, 0x13, 0x14, 0x16, 0x17, 0x12, 0x18, 0x19, 0x25, 0x16, 0x26, 0x27 },
	{ 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x17, 0x17, 0x19, 0x19, 0x16, 0x26, 0x27 },
	{ 0x15, 0x15, 0x15, 0x18, 0x18, 0x18, 0x13, 0x13, 0x11, 0x19, 0x16, 0x26, 0x27 },
	{ 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x16, 0x26, 0x27 },

	//筒子好牌
	{ 0x21, 0x21, 0x22, 0x22, 0x23, 0x23, 0x24, 0x24, 0x15, 0x15, 0x26, 0x16, 0x17 },
	{ 0x28, 0x28, 0x29, 0x29, 0x27, 0x26, 0x25, 0x24, 0x15, 0x15, 0x26, 0x16, 0x17 },
	{ 0x21, 0x22, 0x23, 0x24, 0x26, 0x27, 0x22, 0x28, 0x29, 0x15, 0x26, 0x16, 0x17 },
	{ 0x21, 0x21, 0x21, 0x22, 0x22, 0x22, 0x27, 0x27, 0x29, 0x29, 0x26, 0x16, 0x17 },
	{ 0x25, 0x25, 0x25, 0x28, 0x28, 0x28, 0x23, 0x23, 0x21, 0x29, 0x26, 0x16, 0x17 },
	{ 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 0x26, 0x16, 0x17 },
};



void Combine111(/*BYTE_VECTOR &srcVec, */int n, int m, std::vector<std::vector<BYTE>>& idexVec)
{
	if (m > n)
	{
		return;
	}
	std::vector<BYTE> vecTem;
	//int* pTable = new int[n];       //定义标记buf并将其前m个置1  
	std::vector<BYTE> pTable;
	pTable.resize(n);
	//memset(pTable, 0, sizeof(int)*n);
	for (int i = 0; i < m; ++i)
	{
		pTable[i] = 1;
	}
	bool bFind = false;
	do
	{
		vecTem.clear();
		for (int i = 0; i < n; i++)  //打印当前组合  
		{
			if (pTable[i])
			{
				vecTem.push_back(i);
			}
		}
		if (0 != vecTem.size())
		{
			idexVec.emplace_back(vecTem);
		}

		bFind = false;
		for (int i = 0; i < n - 1; i++)
		{
			if (pTable[i] == 1 && pTable[i + 1] == 0)
			{
				std::swap(pTable[i], pTable[i + 1]);    //调换10为01  
				bFind = true;

				if (pTable[0] == 0)  //如果第一位为0，则将第i位置之前的1移到最左边，如为1则第i位置之前的1就在最左边，无需移动  
				{
					for (int k = 0, j = 0; k < i; k++)   //O(n)复杂度使1在前0在后  
					{
						if (pTable[k])
						{
							std::swap(pTable[k], pTable[j]);
							j++;
						}
					}
				}

				break;
			}
		}
	} while (bFind);

	//delete[] pTable;
}

int _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
	std::vector<std::vector<BYTE>> vvvec;
	Combine111(5, 3, vvvec);
	int nummm = vvvec.size();
	int idex = sizeof(speciaCards) / sizeof(speciaCards[0]);

	BYTE ARRTEM[13] = { 0 };
	for (int i = 0; i < idex; ++i)
	{
		memcpy(ARRTEM, speciaCards[i], 13);
	}

	int nRetCode = 0;

	HMODULE hModule = ::GetModuleHandle(NULL);

	if (hModule != NULL)
	{
		// initialize MFC and prBYTE and error on failure
		if (!AfxWinInit(hModule, NULL, ::GetCommandLine(), 0))
		{
			// TODO: change error code to suit your needs
			_tprintf(_T("Fatal Error: MFC initialization failed\n"));
			nRetCode = 1;
		}
		else
		{
			// TODO: code your application's behavior here.
			std::vector<std::string> testStr;
			testStr.emplace_back("ab");
			testStr.emplace_back("ab");
			testStr.emplace_back("ab");
			testStr.emplace_back("ab");
			CString tstCs;
			for (auto ptr = testStr.begin(); ptr != testStr.end(); ++ptr)
			{
				tstCs.AppendFormat(("%s + "), (*ptr).c_str());
			}
			//AfxMessageBox(tstCs);

			vector<pair<WORD, WORD>> tVector;
			tVector.push_back(make_pair(11, 44));
			tVector.push_back(make_pair(23, 24));
			tVector.push_back(make_pair(44, 74));
			tVector.push_back(make_pair(33, 54));
			sort(tVector.begin(), tVector.end(), [](pair<WORD, WORD>& lf, pair<WORD, WORD>& ri)
			{
				return lf.second > ri.second;
			});
			BYTE offset = 0;
			BYTE baseCards[] =
			{
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,	//方块 A - K
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,	//梅花 A - K
				0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D,	//红桃 A - K
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D	//黑桃 A - K

			};

			BYTE modifyCards[] =
			{
				0x28, 0x25, 0x07, 0x11, 0x25, 0x28, 0x29, 0x14, 0x18, 0x19, 0x21, 0x22, 0x15
			};

			BYTE modifyCards11[] =
			{
				0x24, 0x25, 0x27, 0x21, 0x25, 0x28, 0x29, 0x24, 0x28, 0x29, 0x21, 0x22, 0x05
			};

	

			//ChangeCards(offset, baseCards, modifyCards, CountArray(modifyCards), CountArray(baseCards) - offset);
			//ChangeCards(offset, baseCards, modifyCards11, CountArray(modifyCards11), CountArray(baseCards) - offset);
			//ShowArr(baseCards);

			vector<string> userVec;//用户
			BYTE cardARr[13] = { 0 };
			BYTE cardARr1[13] = { 0 };
			CSpeciallyCard specUSer;
			specUSer.userNum = 2;
			//CSpeciallyCard cardStru;
			std::vector<SpeciallyCardStru> cardVec;
			specUSer.GetEspeciallyCards(baseCards, sizeof(baseCards) / sizeof(baseCards[0]), cardVec);
			//specUSer.GetEspeciallyCards(cardARr1);
			ShowArr(baseCards, sizeof(baseCards) / sizeof(baseCards[0]), 13);
		}
	}
	else
	{
		// TODO: change error code to suit your needs
		_tprintf(_T("Fatal Error: GetModuleHandle failed\n"));
		nRetCode = 1;
	}

	return nRetCode;
}
